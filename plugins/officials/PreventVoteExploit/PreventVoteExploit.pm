package PreventVoteExploit;

use strict;

use SpadsPluginApi;

no warnings 'redefine';

my $pluginVersion='0.3';
my $requiredSpadsVersion='0.11.10';

sub getVersion { return $pluginVersion; }
sub getRequiredSpadsVersion { return $requiredSpadsVersion; }
sub getParams { return [{ immuneLevel => ['integer']},{}]; }

sub new {
  my $class=shift;
  my $self = {};
  bless($self,$class);
  slog("Plugin loaded (version $pluginVersion)",3);
  return $self;
}

sub getUserIps {
  my $user=shift;
  my %ips;
  my $spring=getSpringInterface();
  if($spring->getState()) {
    my $p_ahPlayer=$spring->getPlayer($user);
    if(%{$p_ahPlayer} && $p_ahPlayer->{address}) {
      my $addr=$p_ahPlayer->{address};
      $addr=$1 if($addr =~ /^\[(?:::ffff:)?(\d+(?:\.\d+){3})\]:\d+$/);
      $ips{$addr}=1 if($addr =~/^\d+(?:\.\d+){3}$/);
    }
  }
  my $lobby=getLobbyInterface();
  $ips{$lobby->{users}{$user}{ip}}=1 if(exists $lobby->{users}{$user} && defined $lobby->{users}{$user}{ip});
  return (keys %ips);
}

sub onVoteRequest {
  my ($source,$user,$p_remainingVoters)=($_[1],$_[2],$_[4]);
  my $p_conf=getPluginConf();
  my %ipAddresses;
  foreach my $player ($user,keys %{$p_remainingVoters}) {
    next unless(getUserAccessLevel($player) >= $p_conf->{immuneLevel});
    my @playerIps=getUserIps($player);
    next unless(@playerIps);
    foreach my $ipAddr (@playerIps) {
      $ipAddresses{$ipAddr}=[] unless(exists $ipAddresses{$ipAddr});
      push(@{$ipAddresses{$ipAddr}},$player);
    }
  }
  if(getUserAccessLevel($user) < $p_conf->{immuneLevel}) {
    my @userIps=getUserIps($user);
    foreach my $ipAddr (@userIps) {
      if(exists $ipAddresses{$ipAddr}) {
        my @allowedPlayers=@{$ipAddresses{$ipAddr}};
        slog("Denying vote call for player $user (sharing same IP address as player".($#allowedPlayers > 0 ? 's ' : ' ').(join(',',@allowedPlayers)).')',3);
        if($source eq 'pv') {
          sayPrivate($user,'You are not allowed to call a vote (vote exploit protection)');
        }else{
          sayBattleAndGame("Denying vote call for player $user (vote exploit protection)");
        }
        return 0;
      }
    }
    foreach my $ipAddr (@userIps) {
      $ipAddresses{$ipAddr}=[] unless(exists $ipAddresses{$ipAddr});
      push(@{$ipAddresses{$ipAddr}},$user);
    }
  }
  my %playersToRemove;
  foreach my $player (keys %{$p_remainingVoters}) {
    next unless(getUserAccessLevel($player) < $p_conf->{immuneLevel});
    my @playerIps=getUserIps($player);
    next unless(@playerIps);
    foreach my $ipAddr (@playerIps) {
      if(exists $ipAddresses{$ipAddr}) {
        $playersToRemove{$ipAddr}=[] unless(exists $playersToRemove{$ipAddr});
        push(@{$playersToRemove{$ipAddr}},$player);
      }else{
        $ipAddresses{$ipAddr}=[$player];
      }
    }
  }
  foreach my $ipAddr (keys %playersToRemove) {
    my @removedPlayers=@{$playersToRemove{$ipAddr}};
    my @allowedPlayers=@{$ipAddresses{$ipAddr}};
    slog('Denying vote for player'.($#removedPlayers > 0 ? 's ' : ' ').(join(',',@removedPlayers)).' (sharing same IP address as player'.($#allowedPlayers > 0 ? 's ' : ' ').(join(',',@allowedPlayers)).')',3);
    delete @{$p_remainingVoters}{@removedPlayers};
  }
  return 1;
}

1;
